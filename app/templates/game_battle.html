{% extends "base.html" %}
{% block content %}
<h2>Trận chiến #{{ game.id }}</h2>
<p>Người chơi: {{ player_name }} vs {{ opponent_name }}</p>

<div style="margin-top: 10px;">
  <button onclick="requestUndo()">Undo (Hoàn tác)</button>
  <button onclick="requestRedo()">Redo (Làm lại)</button>
</div>

<div style="display:flex;gap:50px;">
  <div>
    <h3>Bảng của bạn</h3>
    <table id="playerBoard"></table>
  </div>

  <div>
    <h3>Bảng của {{ opponent_name }}</h3>
    <table id="opponentBoard"></table>
  </div>

</div>

<p id="status"></p>

{% if game.ai %}
<div id="aiPanel" style="min-width:300px;">
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
    <h3 style="margin: 0;">Hoạt động của AI</h3>
    <button onclick="toggleAiPanel()" id="btnToggleAi" style="padding: 2px 8px; cursor: pointer;">Thu gọn</button>
  </div>
  <div id="aiContent" style="display: flex; gap: 15px;">
    <div id="aiLogs" style="flex: 1; height:350px; overflow-y:auto; border:1px solid gray; padding:5px; background:#fafafa;"></div>
    <div>
      <h4 id="aiBoardTitle" style="display: none; margin-top: 0;"></h4>
      <div id="aiBoard" style="display: none;"></div>
    </div>
  </div>
</div>
{% endif %}



<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script>
const socket = io();
const gameId = "{{ game.id }}";
const playerName = "{{ player_name }}";
const isHost = "{{ is_host }}".toLowerCase() === "true";
const opponentName = "{{ opponent_name }}";
let currentTurn = "{{ game.current_turn }}";

socket.emit("join_room", { room: gameId });

const playerBoardData = JSON.parse(`{{ player_board|safe }}`);  // safe ở đây liên quan đến bảo mật, jinja sẽ không bỏ qua mã html
const opponentBoardData = JSON.parse(`{{ opponent_board|safe }}`);

const size = 10;
const playerBoard = document.getElementById("playerBoard");
const opponentBoard = document.getElementById("opponentBoard");

function makeBoard(table, data, hideShips=false, isOpponent=false) {
  table.innerHTML = "";
  for (let i = 0; i < size; i++) {
    const row = document.createElement("tr");
    for (let j = 0; j < size; j++) {
      const cell = document.createElement("td");
      cell.dataset.x = i;
      cell.dataset.y = j;
      cell.style.width = "30px";
      cell.style.height = "30px";
      cell.style.border = "1px solid black";
      cell.style.textAlign = "center";
      const val = data ? data[i][j] : 0;

      // nếu là bảng của mình → luôn thấy tàu
      // nếu là bảng đối thủ → ẩn tàu (val==1) thành trắng
      if (val === 1 && !hideShips) cell.style.background = "lightblue";
      else if (val === 2) cell.style.background = "tomato";     // hit
      else if (val === 3) cell.style.background = "lightgray";    // miss
      else if (val === 4) cell.style.background = "crimson";   // sunk

      if (isOpponent) {
        cell.style.cursor = "pointer";
        cell.addEventListener("click", () => fireAt(i, j));
      }

      row.appendChild(cell);
    }
    table.appendChild(row);
  }
}

makeBoard(playerBoard, playerBoardData, false, false);
makeBoard(opponentBoard, opponentBoardData, false, true);

// Vô hiệu hóa chọn bảng đối thủ nếu chưa tới lượt
function disableOpponentBoard(disabled) {
  // Nếu không truyền giá trị vào, mặc định là true
  if (disabled === undefined) {
    disabled = true;
  }

  const cells = opponentBoard.querySelectorAll("td");

  // Duyệt qua từng ô (một cách cổ điển)
  for (let i = 0; i < cells.length; i++) {
    const td = cells[i];

    // Nếu disabled = true → cấm bắn
    if (disabled === true) {
      td.style.cursor = "not-allowed"; // đổi hình chuột
      td.style.opacity = "0.6";        // làm mờ đi
    } else {
      // Ngược lại → cho phép bắn
      td.style.cursor = "pointer";
      td.style.opacity = "1";
    }
  }
}


function fireAt(x, y) {
    if (currentTurn !== playerName) {
      document.getElementById("status").textContent = "Chưa đến lượt bạn!";
      return;
    }

    const cell = opponentBoard.querySelector(`[data-x="${x}"][data-y="${y}"]`);
    if (!cell || cell.classList.contains("fired")) return;

    // tạm khóa click trong khi chờ server phản hồi
    disableOpponentBoard(true);
    cell.classList.add("fired");
    cell.style.cursor = "not-allowed";
    document.getElementById("status").textContent = "Đang bắn";

    socket.emit("player_fire", { game_id: gameId, player: playerName, x, y });
}

// Nhận kết quả bắn
socket.on("shot_result", (data) => {
    const { x, y, result, attacker, target} = data;

    // Nếu server gửi attacker/target, xác định bản đồ cần cập nhật:
    // - Nếu tôi là target -> update playerBoard
    // - Nếu tôi là attacker -> update opponentBoard
    const table = (playerName === target) ? playerBoard : opponentBoard;
    const cell = table.querySelector(`[data-x="${x}"][data-y="${y}"]`);
    const color =
      result === "hit" ? "tomato" :
      result === "sunk" ? "crimson" :
      result === "miss" ? "lightgray" : "white";
    if (cell) cell.style.background = color;


  // Thông báo trạng thái (tùy theo là attacker hay target)
  if (playerName === attacker) {
      if (result === "hit") document.getElementById("status").textContent = "Bắn trúng!";
      else if (result === "sunk") document.getElementById("status").textContent = "Đánh chìm!";
      else if (result === "miss") document.getElementById("status").textContent = "Trượt rồi!";
    } else {
      if (result === "hit") document.getElementById("status").textContent = "Địch bắn trúng bạn!";
      else if (result === "miss") document.getElementById("status").textContent = "Địch bắn hụt!";
      else if (result === "sunk") document.getElementById("status").textContent = "Địch đánh chìm tàu bạn!";
    }
});

//tàu chìm thì tô lại các ô trong comp
socket.on("ship_sunked", (data) => {
  const { owner, ship_name, comp } = data;
  const table = (playerName === owner) ? playerBoard : opponentBoard;
  comp.forEach( ([x,y]) => {
        const cell = table.querySelector(`[data-x="${x}"][data-y="${y}"]`).style.background = "crimson";
  })
})

// Khi game kết thúc (có người thắng)
socket.on("game_over", (data) => {
    const { winner, redirect_url } = data;
    const msg = (winner === playerName)
      ? "Bạn đã chiến thắng! Đang chuyển hướng..."
      : "Bạn đã thua... Đang quay lại chi tiết trận đấu.";
    
    document.getElementById("status").textContent = msg;

    // Khóa bảng bắn
    disableOpponentBoard(true);

    // Chờ 2 giây rồi chuyển hướng
    setTimeout(() => {
      window.location.href = redirect_url;
    }, 2000);
});

// Nhận thông báo đổi lượt
socket.on("turn_change", (data) => {
    currentTurn = data.current_turn;
    if (currentTurn === playerName) {
      document.getElementById("status").textContent = "Đến lượt bạn!";
      disableOpponentBoard(false);
    } else {
      document.getElementById("status").textContent = "Đợi lượt của đối thủ...";
      disableOpponentBoard(true);

      //Nếu là ai bắn thì gửi yêu cầu bắn cho AI
      if (data.is_ai_turn) {
        console.log("[DEBUG] Đến lượt AI, gửi yêu cầu bắn...");
        socket.emit("ai_make_shot", { game_id: gameId });
      }
    }
});

socket.on("ai_log_update", (data) => {
  console.log("prob_matrix:", data.prob_matrix);
  //Cập nhật log
  logBox = document.getElementById("aiLogs");
  p = document.createElement("p");
  p.textContent = `${data.ai_name}: ${data.message}`;
  logBox.appendChild(p);
  logBox.scrollTop = logBox.scrollHeight; //Cuộn xuống dòng

  // Cập nhật thêm (nếu có)
  if (data.prob_matrix) {
    renderAiBoard(data.ai_name, data.prob_matrix);
  }
});

function renderAiBoard(aiName, matrix) {
  fetch("/render_matrix", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      matrix: matrix,
      heatmap: true
    })
  })
  .then(res => res.text()) // chuyển phản hồi thành text HTML
  .then(html => {
    // Gắn bảng vào giao diện
    const titleEl = document.getElementById("aiBoardTitle");
    const boardEl = document.getElementById("aiBoard");
    titleEl.style.display = "block";
    boardEl.style.display = "block";
    titleEl.textContent = `${aiName}'s Board`;
    boardEl.innerHTML = html;

    const tdList = document.querySelectorAll('#aiBoard td[data-alpha]');
    const alphas = Array.from(tdList).map(td => parseFloat(td.dataset.alpha));

    // Loại bỏ ô 0 khi tính min/max
    const nonZero = alphas.filter(a => a > 0);
    const minA = Math.min(...nonZero);
    const maxA = Math.max(...nonZero);
    const range = Math.max(maxA - minA, 1e-6); // tránh chia cho 0

    tdList.forEach(td => {
      const a = parseFloat(td.dataset.alpha);

      if (a < 0) {
        td.style.backgroundColor = "rgb(150, 200, 255)"; // trượt - xanh nhạt
      } else if (a === 0) {
        td.style.backgroundColor = "rgba(200, 0, 40, 1)"; // trúng - đỏ đậm
        td.style.color = "white";
      } else if (a > 0) {
        // Gradient cho xác suất
        const norm = (a - minA) / range;
        const r = 255;
        const g = Math.round(220 * (1 - norm));
        const b = Math.round(220 * (1 - norm));
        td.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
        td.style.color = norm > 0.6 ? "white" : "black";
      } else {
        td.style.backgroundColor = "white";
      }

      td.textContent = a.toFixed(1);
    });
  })
  .catch(err => console.error("Render matrix error:", err));
}

function toggleAiPanel() {
  const content = document.getElementById("aiContent");
  const btn = document.getElementById("btnToggleAi");
  if (content.style.display === "none") {
    content.style.display = "flex";
    btn.textContent = "Thu gọn";
  } else {
    content.style.display = "none";
    btn.textContent = "Mở rộng";
  }
}

function requestUndo() {
  socket.emit("undo_move", { game_id: gameId });
}

function requestRedo() {
  socket.emit("redo_move", { game_id: gameId });
}

socket.on("board_updated", (data) => {
  if (data.owner === playerName) {
      // Nếu bảng của mình bị thay đổi (do mình bị bắn và undo lại)
      makeBoard(playerBoard, data.board, false, false);
  } else {
      // Nếu bảng đối thủ bị thay đổi (do mình bắn và undo lại)
      // hideShips=true để đảm bảo không lộ tàu khi nhận dữ liệu raw
      makeBoard(opponentBoard, data.board, false, true);
  }
});

</script>
{% endblock %}
